package com.java_podio.code_gen;

import java.text.ParseException;
import java.util.List;

import com.google.common.base.CaseFormat;
import com.podio.app.Application;
import com.podio.app.ApplicationField;
import com.podio.item.FieldValuesUpdate;
import com.podio.item.FieldValuesView;
import com.podio.item.Item;
import com.podio.item.ItemCreate;
import com.podio.item.ItemUpdate;
import com.sun.codemodel.JCase;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JConditional;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JDocComment;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JExpression;
import com.sun.codemodel.JForEach;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JOp;
import com.sun.codemodel.JPackage;
import com.sun.codemodel.JSwitch;
import com.sun.codemodel.JVar;

/**
 * Generates a java wrapper for a given podio app.
 */
public class AppGenerator {

	private static final String FIELD_IS_OF_UNSUPPORTET_TYPE_JAVADOC = "Field is of unsupportet type and is not parsed, hence always {@code null}!";

	protected JCodeModel jCodeModel;

	/**
	 * Constructor - constructing an object from an {@link Item}.
	 */
	JMethod constructorFromItem;

	/**
	 * Sets values from a given {@link Item}.
	 */
	JMethod _setValue;

	/**
	 * Constructs a {@link ItemCreate} from current instance. As
	 * {@link ItemCreate} inherits from {@link ItemUpdate}, the result can be
	 * used for updates as well.
	 */
	private JMethod _getItemCreate;

	/**
	 * Initialized after first call of {@link #_getItemCreate()}.
	 */
	private JVar _itemCreateFieldValues;

	protected JDefinedClass currencyClass;

	private EnumGenerator enumGenerator;

	protected JPackage jp;

	protected AppWrapperGenerator appWrapperGenerator;

	protected CurrencyGenerator currencyGenerator;

	/**
	 * The generated app class.
	 */
	private JDefinedClass jc = null;

	private JForEach setValuesFromItemForEachField;

	private JSwitch setValuesFromItemSwitch;

	private JVar itemCreateResult;

	public AppGenerator(JCodeModel jCodeModel, JPackage jPackage, AppWrapperGenerator appWrapperGenerator,
			CurrencyGenerator currencyGenerator) throws JClassAlreadyExistsException {
		this.jCodeModel = jCodeModel;
		this.jp = jPackage;
		this.appWrapperGenerator = appWrapperGenerator;
		this.currencyGenerator = currencyGenerator;
		this.currencyClass = currencyGenerator.getCurrencyClass();
	}

	/**
	 * Generates a wrapper class for a podio app.
	 * 
	 * @return
	 * @throws JClassAlreadyExistsException
	 * @param app
	 * @return
	 */
	public JDefinedClass getAppClass(Application app) throws JClassAlreadyExistsException {
		// Debug:
		// CodeGenerator.printApp(app);

		String className = JavaNames.createValidJavaTypeName(app.getConfiguration().getName(), jp.name());
		jc = jp._class(className)._extends(appWrapperGenerator.getAppWrapperClass());

		_setValue = null;
		_setValue = _setValue();
		_getItemCreate = null;
		_getItemCreate = _getItemCreate();

		enumGenerator = new EnumGenerator(jCodeModel, jp.subPackage(CaseFormat.UPPER_CAMEL.to(
				CaseFormat.LOWER_UNDERSCORE, className)));

		JDocComment jDocComment = jc.javadoc();
		jDocComment.add("Wrapper for podio app '" + app.getConfiguration().getName() + "' (id=" + app.getId()
				+ ").\nGenerated by java-podio-code-gen.");

		jc.method(JMod.PUBLIC, Integer.class, "getAppId").body()._return(JExpr.lit(app.getId()));
		jc.method(JMod.PUBLIC, String.class, "getAppExternalId")
				.body()
				._return(
						JExpr.lit(app.getConfiguration().getExternalId() == null ? "" : app.getConfiguration()
								.getExternalId()));

		// TODO add field ids (id/externalId)?

		// Default constructor:
		jc.constructor(JMod.PUBLIC);

		// itemConstructor:
		constructorFromItem = jc.constructor(JMod.PUBLIC);
		JVar constructorFromItemParam = constructorFromItem.param(Item.class,
				CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, className) + "Item");
		constructorFromItem.body().invoke(_setValue()).arg(constructorFromItemParam);

		for (ApplicationField f : app.getFields()) {
			String name = CaseFormat.LOWER_HYPHEN.to(CaseFormat.UPPER_CAMEL, f.getExternalId().toLowerCase());
			PodioType type = PodioType.forApplicationField(f);

			String javadoc = f.getConfiguration().getDescription();
			if (type.equals(PodioType.UNDEFINED)) {
				javadoc = javadoc == null ? FIELD_IS_OF_UNSUPPORTET_TYPE_JAVADOC : javadoc + "\n"
						+ FIELD_IS_OF_UNSUPPORTET_TYPE_JAVADOC;
			}

			JClass javaType = getType(type, f);
			JMember field = CodeGenerator.addMember(jc, name, javaType, javadoc, jCodeModel,
					com.podio.app.ApplicationFieldStatus.DELETED.equals(f.getStatus()));

			// add setValuesFromItem part:
			JCase jcase = setValuesFromItemSwitch._case(JExpr.lit(f.getId()));
			jcase.body().invoke(field.getSetter())
					.arg(createGetFieldValue(type, setValuesFromItemForEachField.var(), javaType));
			jcase.body()._break();

			// add getItemCreate part:
			JExpression fieldValueUpdate = createFieldValuesUpdate(field.getGetter(), type, f);
			if (fieldValueUpdate != null) {
				JConditional cond = _getItemCreate().body()._if(JExpr.invoke(field.getGetter()).ne(JExpr._null()));
				cond._then().add(_itemCreateFieldValues.invoke("add").arg(fieldValueUpdate));
			}
		}

		_getItemCreate().body()._return(itemCreateResult);

		CodeGenerator.addToString(jc, jCodeModel, true);

		return jc;
	}

	public JMethod _setValue() throws JClassAlreadyExistsException {
		if (_setValue != null) {
			return _setValue;
		}

		_setValue = jc.method(JMod.PUBLIC, jCodeModel.VOID, appWrapperGenerator._setValue().name());
		_setValue.annotate(SuppressWarnings.class).param("value", "unchecked");
		JVar setValuesFromItemParam = _setValue.param(Item.class,
				CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, "item"));
		_setValue.body().add((JExpr._super().invoke(appWrapperGenerator._setValue()).arg(setValuesFromItemParam)));
		setValuesFromItemForEachField = _setValue.body().forEach(jCodeModel.ref(FieldValuesView.class), "field",
				setValuesFromItemParam.invoke("getFields"));
		setValuesFromItemSwitch = setValuesFromItemForEachField.body()._switch(
				setValuesFromItemForEachField.var().invoke("getId"));
		setValuesFromItemSwitch
				._default()
				.body()
				.directStatement(
						"System.out.println(\"ERROR: unexpected field id=\"+field.getId() (App: \"+this.getClass().getName()+\"");
		setValuesFromItemSwitch._default().body()._break();

		return _setValue;
	}

	public JMethod _getItemCreate() {
		if (_getItemCreate != null) {
			return _getItemCreate;
		}
		// getItemCreate method:
		_getItemCreate = jc.method(JMod.PUBLIC, jCodeModel._ref(ItemCreate.class), appWrapperGenerator._getItemCreate()
				.name());
		itemCreateResult = _getItemCreate.body().decl(jCodeModel.ref(ItemCreate.class), "result",
				JExpr._super().invoke(appWrapperGenerator._getItemCreate()));
		_itemCreateFieldValues = _getItemCreate.body().decl(jCodeModel.ref(List.class).narrow(FieldValuesUpdate.class),
				"fieldValuesList", itemCreateResult.invoke("getFields"));

		// as statements are added later, the return statement has to be added
		// later as well!
		// _getItemCreate.body()._return(itemCreateResult);

		return _getItemCreate;

	}

	private JClass getType(PodioType type, ApplicationField f) {
		JClass result;
		switch (type) {
		case MONEY:
			result = currencyClass;
			break;
		case CATEGORY_SINGLE:
			String name = JavaNames.createValidJavaTypeName(f.getConfiguration().getLabel(), jp.name());
			if (f.getConfiguration().getSettings().getMultiple().equals(Boolean.FALSE)) {

				try {
					result = enumGenerator.generateEnum(f, name);
				} catch (JClassAlreadyExistsException e) {
					System.out.println("ERROR: could not generate enum with name: " + name + "(might exist twice?!)");
					e.printStackTrace();
					result = jCodeModel.ref(Integer.class);
				}
			} else {
				System.out.println("ERROR: Categories with multiple values not supportet yet! (Category: "
						+ f.getConfiguration().getLabel() + ")");
				result = jCodeModel.ref(Void.class);
			}
			break;
		case APP:
			result = jCodeModel.ref(List.class).narrow(Integer.class);
			break;

		default:
			result = jCodeModel.ref(type.getJavaType());
			break;
		}
		return result;
	}

	/**
	 * JavaType -> Item
	 * 
	 * @param getter
	 * @param type
	 *            (return-)type of {@code getter}
	 * @param f
	 *            corresponds to (field of) {@code getter}
	 * @return an {@link JExpression} that evaluates to a
	 *         {@link FieldValuesUpdate} containing the return value of
	 *         {@code getter}. If the field type is not supported, returns
	 *         {@code null}.
	 * @throws JClassAlreadyExistsException
	 */
	private JExpression createFieldValuesUpdate(JMethod getter, PodioType type, ApplicationField f)
			throws JClassAlreadyExistsException {
		switch (type) {
		case TEXT:
			return JExpr
					._new(jCodeModel.ref(FieldValuesUpdate.class))
					.arg(f.getExternalId())
					.arg("value")
					.arg(JOp.cond(JExpr.invoke(getter).invoke("length").eq(JExpr.lit(0)), JExpr.lit(" "),
							JExpr.invoke(getter)));
		case NUMBER:
			return JExpr._new(jCodeModel.ref(FieldValuesUpdate.class)).arg(f.getExternalId()).arg("value")
					.arg(JExpr.invoke(getter));
		case MONEY:
			return JExpr.invoke(getter).invoke("getFieldValuesUpdate").arg(JExpr.lit(f.getExternalId()));
		case CATEGORY_SINGLE:
			// new FieldValuesUpdate("status", "value",
			// customer.getPowerStatus().getId())
			return JExpr._new(jCodeModel.ref(FieldValuesUpdate.class)).arg(f.getExternalId()).arg("value")
					.arg(JExpr.invoke(getter).invoke("getPodioId"));
		case APP:
			return JExpr.invoke(appWrapperGenerator._getFieldValuesUpdateFromApp()).arg(JExpr.invoke(getter))
					.arg(f.getExternalId());
		case DATE:
			return JExpr.invoke(appWrapperGenerator._getFieldValuesUpdateFromDate()).arg(JExpr.invoke(getter))
					.arg(f.getExternalId());
		default:
			return null;
		}
	}

	/**
	 * Item -> JavaType
	 * 
	 * @param type
	 * @param jVar
	 *            is expected to be of type {@link FieldValuesView}
	 * @param javaType
	 * @return an {@link JExpression} that evaluates to the value represented in
	 *         {@code jVar} and is of type {@code javaType}.
	 * @throws JClassAlreadyExistsException
	 */
	private JExpression createGetFieldValue(PodioType type, JVar jVar, JClass javaType)
			throws JClassAlreadyExistsException {
		switch (type) {
		case TEXT:
			return createGetStringFieldValue(jVar, "value", jCodeModel);
		case NUMBER:
			return createGetDoubleFieldValue(jVar);
		case MONEY:
			return createGetCurrencyFieldValue(jVar);
		case DATE:
			return createGetDateFieldValue(jVar);
		case CATEGORY_SINGLE:
			JExpression podioId = JExpr.direct("(Integer) ((java.util.Map<String, ?>) " + jVar.name()
					+ ".getValues().get(0).get(\"value\")).get(\"id\")");
			return javaType.staticInvoke("byId").arg(podioId);
			// return JExpr.cast(
			// Integer.class,
			// JExpr.cast(jCodeModel.ref(Map.class).narrow(String.class,
			// Object.class),
			// jVar.invoke("getValues").invoke("get").arg(JExpr.lit(0)).invoke("get").arg("value"))
			// .invoke("id"));
		case APP:
			// ((Map<String, Map<String, Integer>>)
			// field.getValues().get(0)).get("value").get("item_id")
			return JExpr.invoke(appWrapperGenerator._parseAppField()).arg(jVar);

		default:
			System.out.println("WARNING: could not create getFieldValueExpression for type: " + type);
			return JExpr._null();
		}
	}

	/**
	 * @param jVar
	 *            needs to be of type {@link FieldValuesView}.
	 * @return
	 */
	private JExpression createGetCurrencyFieldValue(JVar jVar) {
		return JExpr._new(currencyClass).arg(createGetDoubleFieldValue(jVar))
				.arg(createGetStringFieldValue(jVar, "currency", jCodeModel));
	}

	private JExpression createGetDateFieldValue(JVar jVar) throws JClassAlreadyExistsException {
		_setValue()._throws(ParseException.class);
		constructorFromItem._throws(ParseException.class);
		JExpression exp = createGetStringFieldValue(jVar, "start_date", jCodeModel);
		// 2011-12-31 11:27:10
		return JExpr.invoke(appWrapperGenerator._parseDate()).arg(exp);
	}

	/**
	 * @param jVar
	 *            needs to be of type {@link FieldValuesView}.
	 * @return String cast of field with key {@code field}
	 */
	public static JExpression createGetStringFieldValue(JVar jVar, String field, JCodeModel jCodeModel) {
		return JExpr.cast(jCodeModel._ref(String.class), jVar.invoke("getValues").invoke("get").arg(JExpr.lit(0))
				.invoke("get").arg(field));
	}

	/**
	 * @param jVar
	 *            needs to be of type {@link FieldValuesView}.
	 * @return
	 */
	private JExpression createGetDoubleFieldValue(JVar jVar) {
		// Double.parseDouble((String) field.getValues().get(0).get("value")
		return jCodeModel.ref(Double.class).staticInvoke("parseDouble")
				.arg(createGetStringFieldValue(jVar, "value", jCodeModel));
	}

}
